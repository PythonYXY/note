操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的[内存](https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020)空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

针对[linux操作系统](https://so.csdn.net/so/search?q=linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020)而言，os分配给每个进程一个独立的、连续的、虚拟的地址内存空间，该大小一般是4G（32位操作系统，即2的32次方），其中将高地址值的内存空间分配给os占用，linux os占用1G，window os占用2G；其余内存地址空间分配给进程使用。

在linux系统中将最高的1G字节（从虚拟地址`0xC0000000`到`0xFFFFFFFF`），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址`0x00000000`到`0xBFFFFFFF`），供各个进程使用，称为用户空间。每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。

![](https://img-blog.csdnimg.cn/20210828202113803.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZKL5pS55Liq5ZCN6L-Z5LmI6Zq-5ZGi,size_12,color_FFFFFF,t_70,g_se,x_16)

用户进程缓冲区
-------

缓冲区的目的是为了减少频繁地与设备之间进行物理交换，因为外部设备的直接读写，涉及操作系统的中断。发送系统中断时，需要保存之前的进程数据和状态等信息，而中断结束之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，出现了内存缓冲区。有了内存缓冲区，上层应用使用read系统调用时，仅仅是把数据从内核缓冲区复制到进程缓冲区；在上层应用调用write系统时，仅仅把数据从进程缓冲区复制到内核缓冲区。底层操作会对内核缓冲区进行监控，等待缓冲区达到一定的数量，在进行IO设备的中断处理，集中执行物理设备的实际IO操作。

用户进程通过系统调用访问系统资源的时候，需要切换到内核态，而这对应一些特殊的堆栈和内存环境，必须在系统调用前建立好。而在系统调用结束后，cpu会从核心模式切回到用户模式，而堆栈又必须恢复成用户进程的上下文。而这种切换就会有大量的耗时。

我们在写一些程序在读取文件，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。

所以说：==**用户缓冲区的目的是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。**==

内核缓冲区
-----

除了在进程中设计缓冲区，内核也有自己的缓冲区。当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的io模型，在调度和使用内核缓冲区的方式上有所不同。

可以认为，read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。当然，write并不一定导致内核的写动作，比如os可能会把内核缓冲区的数据积累到一定量后，再一次写入。这也就是为什么断电有时会导致数据丢失。

==所以说**内核缓冲区，是为了在OS级别，提高磁盘IO效率，优化磁盘写操作。**==

详解典型的系统调用流程
-----------

        在我们用户程序空间调用的read和write，并不等价于数据在内核缓冲区和磁盘之间的交换。具体流程可见下图：![](https://img-blog.csdnimg.cn/20210828202134131.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZKL5pS55Liq5ZCN6L-Z5LmI6Zq-5ZGi,size_20,color_FFFFFF,t_70,g_se,x_16)

这里以read一个socket为例子主要包括以下两个阶段：

1.  首先时操作系统来完成以下工作：等待数据从网络中到达网卡，当所有等待的分组到达之后，它被复制到内核中的某个缓冲区当中。
    
2.  数据从内核缓冲区复制到用户缓冲区当中
    

这里以Java服务端为例，完成一次socket请求和响应，完整的流程如下：

1.  客户端发出请求操作：服务器系统通过网卡读取到客户端的数据，将数据读取到内核缓冲区
    
2.  服务器获取请求数据：Java进程通过read系统调用，从系统内核缓冲区中读取数据，存储到Java进程缓冲区
    
3.  服务端进行业务处理：Java进程完成对应的业务处理。
    
4.  服务端返回数据：Java服务端调用系统的write将数据从进程缓冲区写入到服务器的内存缓冲区当中。
    
5.  数据发送给客户端：服务器Linux内核将内核缓冲区的数据写入到网卡中，网卡通过底层的通信协议，将数据发送给目标客户端。