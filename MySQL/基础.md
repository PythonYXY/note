

#  1、一条SQL查询语句是如何执行的

![](https://raw.githubusercontent.com/PythonYXY/pics/main/img/0d2070e8f84c4801adbfa03bda1f98d9.png)



MySQL 可以分为 Server 层和存储引擎层两部分

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

- 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。



缓存：

不建议使用查询缓存，因为对于更新压力大的数据库来说，查询缓存的命中率会非常低，MySQL8.0 开始彻底没有这个功能了。

优化器：

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

例如对于这样一条语句：

>  mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;

既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。



# 2、一条SQL更新语句是如何执行的

更新和查询的流程大致一致，但除此之外，还涉及两个日志模块：redo log（重做日志）和 binlog（归档日志）。

**WAL技术**：当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 **crash-safe**

**bin log**是Server 层自己的日志，用于归档，没有crash-safe能力

| redo log                                       | bin log                |
| ---------------------------------------------- | ---------------------- |
| InnoDB引擎特有                                 | Server层，所有引擎都有 |
| 物理日志，记录的是“在某个数据页上做了什么修改” | 逻辑日志               |
| 循环写，空间有限                               | 追加写                 |

**两阶段提交**：

一个update语句执行流程：

1、执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2、执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 ==prepare 状态==。

4、然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5、执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交==commit状态==，更新完成。

为什么使用两阶段提交，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。（使用反证法论证）



# 3、事务隔离
MySQL引擎对比：

| InnoDB                       | MyIsam                   |
| ---------------------------- | ------------------------ |
| crash-safe能力（redo log）   | 没有crash-safe能力       |
| 支持事务                     | 不支持事务               |
| 行级锁                       | 表级锁                   |
| 支持外键                     | 不支持外键               |
| 通过全标扫描，动态统计表行数 | 存储表行数（不支持条件） |



事务隔离级别：

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

可重复度隔离级别使用场景：对帐单数据做校对时，不希望新插入的数据有影响

==**TODO：隔离级别实现，MVCC**==

==尽量不要使用长事务==：回滚日志删除时机是当系统里没有比这个回滚日志更早的 read-view 的时候。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致**大量占用存储空间**。此外，**长事务还占用锁资源，也可能拖垮整个库**

通过监控information_schema 库的 innodb_trx表，可以及时发现并处理长事务

避免长事务：

- 应用开发端：确认是否使用了 set autocommit=0；确认是否有不必要的只读事务；通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间
- 数据库端：通过监控information_schema 库的 innodb_trx表，可以及时发现并处理长事务



# 4、索引上

实现索引的三种方式：

- 哈希表：适合做等值查询，不适合做范围查询。Memcached、NoSQL
- 有序数组：适合查询，不适合增加数据，只适用于静态存储引擎
- 搜索树：二叉搜索树查询效率不高，读磁盘的次数取决于二叉搜索树树高。建议使用N叉树，“N”取决于数据块的大小



**主键索引**：叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

**非主键索引**：叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

聚簇索引：表记录的物理存储顺序与索引顺序一致，且索引的叶子节点就是数据节点

非聚簇索引：表记录的物理存储顺序与索引顺序无关，叶子节点包含主键值或者指向数据块的指针

| 聚簇索引                                                     | 非聚簇索引                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提升IO密集型应用性能；row的移动不影响二级索引；如果主键非自增，在插入记录时，可能造成记录移动或页分裂，影响性能 | 索引与数据分离，相对聚簇索引占用空间小；InnoDB二级索引相对MyISAM会大；使用InnoDB二级索引需要检索两次B+Tree；随机IO；row的移动会影响MyISAM索引 |

为什么推荐使用自增主键：

- 性能考量：索引必须维持有序性，如果不使用自增主键，插入数据时需要挪动已有数据，同时还可能会造成页分裂和页合并。自增主键每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

- 存储考量：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。



什么场景使用业务字段作为主键：只有一个索引；该索引必须是唯一索引（KV场景）



# 5、索引下

覆盖索引能够减少回表次数，是一个常用的==性能优化手段==



索引下推：MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数



对于如下表，索引ca是不必要的，因为**二级索引会默认和主键做联合索引**

```

CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```





# 6、全局锁和表锁

**全局锁**就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)，使用场景是做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

但是FTWRL有如下问题：如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。



推荐使用mysqldump –single-transaction通过事务获取一致性视图（前提是MySQL引擎支持）



表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)

当对一个表做增删改查操作的时候，加 **MDL 读锁**；当要对表做结构变更操作的时候，加 **MDL 写锁**



修改表结构可能会导致整个库挂掉：因为当修改表的线程在等待给表加写锁时，其他读表的线程只能等待。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。

**如何安全地给小表加字段**？1、防止长事务一直占有MDL写锁。2、alter table 语句里面设定等待时间



# 7、行锁

<u>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。==如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放==</u>



**死锁**：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态



应对死锁有两种策略：

1、一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。（值不能过大也不能过小）

2、另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。（更常用的一种策略）



死锁检测需要消耗大量CPU资源，如何解决由热点行更新导致的性能问题：

1、临时把死锁检测关掉

2、控制并发读（通过引入中间件、修改MySQL源代码、一行改成逻辑上的多行来减少锁冲突等）



# 8、事务隔离

![](https://raw.githubusercontent.com/PythonYXY/pics/main/img/823acf76e53c0bdba7beab45e72e90d6.png)

若k的初始值为1，在上图中，事务A读取到的k值将为1，而事务B读取到的k值将为3。这是由于事务在对数据行做更新时，会执行当前读从而获取到最新值，然后再进行更新。



==**MVCC**==：

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id

每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。通过undo log（逻辑日志）存储历史版本。

InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

数组里面事务 ID 的最小值记为**低水位**，当前系统里面已经创建过的事务 ID 的最大值加 1 记为**高水位**。这个视图数组和高水位，就组成了当前事务的==一致性视图（read-view）==。

数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

![](https://raw.githubusercontent.com/PythonYXY/pics/main/img/882114aaf55861832b4270d44507695e.png)



对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1、如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

2、如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

3、如果落在黄色部分，那就包括两种情况

​	a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；

​	b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。（黄色区间是包含了已经提交的事务的，已经提交的事务的id可以比最低水位大，但小于最高水位。）



# Extra

Mysql Explain之type详解：

https://juejin.cn/post/6844904149864169486

