# 9、普通索引和唯一索引，应该怎么选择？

**change buffer**：

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。



**change buffer使用场景**：

- 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好

- 假设一个业务的更新模式是写入之后马上会做查询，对于这种业务模式来说，change buffer 反而起到了副作用。

change buffer要和普通索引配合使用，不能和唯一索引配合使用



change buffer & redo log：

redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。（本来对不在内存中的数据更新时需要先把数据页读入内存再执行更新操作，但是有了change buffer，就可以先不把数据页读入内存而换成先记录在内存中的change buffer中，等到一定时机再触发merge把内存中的数据页更新，这样就减少了每次更新都要读盘的操作，也就是减少了随机读io。(而且因为change buffer同时也记录在redo log和ibdata1中，如果MySQL宕机，也可以通过崩溃恢复的机制保证记录在change buffer中的记录不丢失。更具体的恢复机制看评论区) 内存中数据页更新了之后，本来是要将更新的数据页立即刷入磁盘的(随机写)，否则MySQL宕机会丢数据；但是有了redo log，因为更新操作记录在了redo log中，不会因为系统宕机丢失数据(崩溃恢复机制)，所以内存数据更新之后就可以不用立即执行写磁盘操作，可以等待一批再随机写入磁盘，所以说redo log减少了随机写磁盘的io，把减少的随机写转换成了顺序写入redo log文件中。）



# 10、MySQL为什么有时候会选错索引？

MySQL 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数

索引选择异常和处理：

1、对于由于索引统计信息不准确导致的问题，你可以用 analyze table 来解决

2、而对于其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。



# 11、怎么给字符串字段加索引

**使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本**

可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。

使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素



如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。

第一种方式是使用倒序存储，第二种方式是使用 hash 字段。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。两者的区别如下：

- 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。
- 在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。
- 从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。



# 12、为什么我的MySQL会“抖”一下？

